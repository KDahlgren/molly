package edu.berkeley.cs.boom.molly.wrappers

import edu.berkeley.cs.boom.molly.UltimateModel
import edu.berkeley.cs.boom.molly.ast.{IntLiteral, Program}
import jnr.ffi.LibraryLoader
import com.typesafe.scalalogging.LazyLogging
import edu.berkeley.cs.boom.molly.codegen.C4CodeGenerator
import nl.grons.metrics.scala.InstrumentedBuilder
import com.codahale.metrics.MetricRegistry

//KD :
import java.util.concurrent.atomic.AtomicInteger
import java.io._

// ################################################### //
import scala.io.Source //KD
// ################################################### //

class C4Wrapper(name: String, program: Program, runId: AtomicInteger)
               (implicit val metricRegistry: MetricRegistry)  extends LazyLogging with InstrumentedBuilder {

  private val time = metrics.timer("time")

  def run: UltimateModel = C4Wrapper.synchronized {


//    // ################################################### //
//    println("this is a test. kd") //KD
//    //KD :
//    //val iapyx_file = "/Users/KsComp/projects/molly/src/main/scala/edu/berkeley/cs/boom/molly/wrappers/iapyx_prog.olg"
//    //val iapyx_tables_file = "/Users/KsComp/projects/molly/src/main/scala/edu/berkeley/cs/boom/molly/wrappers/iapyx_tables.data"
//
//    val iapyx_file = "/Users/KsComp/projects/iapyx/vldb_experiments/tmp_data/program_dml.olg"
//    val iapyx_tables_file = "/Users/KsComp/projects/iapyx/vldb_experiments/tmp_data/tables_dml.olg"
//
//    //KD : concatenates all lines, returns String :
//
//    val iapyx_prog = Source.fromFile( iapyx_file ).getLines.mkString
//    println( "iapyx_prog : " )
//    println( iapyx_prog )
//
//    val iapyx_tables = Source.fromFile( iapyx_tables_file ).getLines.mkString
//    println( "iapyx_tables:" )
//    println( iapyx_tables )
//
//    // ################################################### //

    time.time {
      C4Wrapper.libC4.c4_initialize()
      val c4 = C4Wrapper.libC4.c4_make(null, 0)

//      // ################################################### //
//
//      //KD : branch here to input iapyx file, if applicable
//      if ( iapyx_prog.length() > 1 ) {
//        println( "the string has length greater than 0" )
//
//        //KD : break execution if the program uses next_clock facts.
//        //     need this b/c would otherwise need to reflect fault injections
//        //     in the next_clock relation as well, which is a pain at this point
//        //     until we get async ldfi together.
//        val nextClockIndex = iapyx_prog.indexOf( "next_clock(\"" )
//
//        if ( nextClockIndex > 0 ) {
//          println( "" )
//          println( "!!!                                                         !!!" )
//          println( "!!!  KD : FATAL ERROR : molly does not support next_clock.  !!!" )
//          println( "!!!                                                         !!!" )
//          println( "" )
//          System.exit(1)
//        }
//
//        //KD : after supporting next_clock, use these lines :
//        //val nextClockIndex            = iapyx_prog.indexOf( "next_clock(\"" )
//        //val iapyx_prog_no_next_clocks = if ( nextClockIndex > 0 ) iapyx_prog.substring( 0, nextClockIndex ) else iapyx_prog
//        //val clockIndex           = iapyx_prog_no_next_clocks.indexOf( "clock(\"" )
//        //val iapyx_prog_no_clocks = if ( clockIndex > 0 ) iapyx_prog_no_next_clocks.substring( 0, clockIndex ) else iapyx_prog_no_next_clocks
//
//        //KD : remove all clock facts from iapyx_prog
//        //     only works b/c added facts ordered by crash, next_clock, clock.
//        //     just delete everything after the first instance of 'clock'.
//
//        val clockIndex           = iapyx_prog.indexOf( "clock(\"" )
//        val iapyx_prog_no_clocks = if ( clockIndex > 0 ) iapyx_prog.substring( 0, clockIndex ) else iapyx_prog
//
//        println( "iapyx_prog_no_clocks :" )
//        println( iapyx_prog_no_clocks )
//
//        //KD : use the clock generated by molly for this loop 
//        //     (cool b/c includes all fault injections)
//
//        val (kd_clockFacts, kd_nonClockFacts) = program.facts.partition(_.tableName == "clock")
//        val kd_clockFactsProgram = C4CodeGenerator.generate(new Program(Nil, kd_clockFacts, Nil))
//        println("C4 clock facts :\n" + kd_clockFactsProgram )
//
//        //KD : install prog and clocks into c4
//        try {
//
//          //KD : install all rule and non-clock facts
//          assert( C4Wrapper.libC4.c4_install_str( c4, iapyx_prog_no_clocks ) == 0 )
//
//          //KD : install all clock facts
//          val clockFactsByTime = kd_clockFacts.groupBy(_.cols(2).asInstanceOf[IntLiteral].int)
//
//          for ((time, facts) <- clockFactsByTime.toSeq.sortBy(_._1)) {
//            val kd_clockFactsProgram = C4CodeGenerator.generate(new Program(Nil, facts, Nil))
//            logger.debug(s"Installing clock facts for time $time:\n$kd_clockFactsProgram")
//            assert(C4Wrapper.libC4.c4_install_str(c4, kd_clockFactsProgram) == 0)
//          }
//
//          //KD : save results into program tables
//          val tables = program.tables.map {
//            t => (t.name, parseTableDump(C4Wrapper.libC4.c4_dump_table(c4, t.name)) )
//          }.toMap
//          new UltimateModel(tables)
//
//        } finally {
//
//
//          //KD : get evaluation results
//
//          val eval_results_file = new PrintWriter(new File( "eval_results_file_" + runId + ".txt"  ))
//          val table_list        = iapyx_tables.split( "," )
//
//          for ( t <- table_list ) {
//            println( "---------------------------" + runId )
//            println( t )
//            val eval_res = C4Wrapper.libC4.c4_dump_table(c4, t)
//            println( eval_res )
//
//            eval_results_file.write( "---------------------------" + "\n" )
//            eval_results_file.write( t + "\n" )
//            eval_results_file.write( eval_res + "\n" )
//          }
//          eval_results_file.close
//
//          //KD : clean up c4 instance
//          C4Wrapper.libC4.c4_destroy(c4)
//          C4Wrapper.libC4.c4_terminate()
//        }
//
//      } else {
//        println( "executing else in c4 wrapper...we gots probs." )
//        //KD : existing molly process :
//        try {
//          // Install the clock facts one timestep at a time in order to stratify the
//          // execution by time:
//          val (clockFacts, nonClockFacts) = program.facts.partition(_.tableName == "clock")
//          val rulesPlusNonClockFacts = C4CodeGenerator.generate(program.copy(facts=nonClockFacts))
//          logger.debug("C4 input minus clock facts is:\n" + rulesPlusNonClockFacts)
//          assert(C4Wrapper.libC4.c4_install_str(c4, rulesPlusNonClockFacts) == 0)
//          val clockFactsByTime = clockFacts.groupBy(_.cols(2).asInstanceOf[IntLiteral].int)
//          for ((time, facts) <- clockFactsByTime.toSeq.sortBy(_._1)) {
//            val clockFactsProgram = C4CodeGenerator.generate(new Program(Nil, facts, Nil))
//            logger.debug(s"Installing clock facts for time $time:\n$clockFactsProgram")
//            assert(C4Wrapper.libC4.c4_install_str(c4, clockFactsProgram) == 0)
//          }
//          val tables = program.tables.map {
//            t => (t.name, parseTableDump(C4Wrapper.libC4.c4_dump_table(c4, t.name)))
//          }.toMap
//          new UltimateModel(tables)
//        } finally {
//          C4Wrapper.libC4.c4_destroy(c4)
//          C4Wrapper.libC4.c4_terminate()
//        }
//      }//end of else
//      // ################################################### //
      try {
        // Install the clock facts one timestep at a time in order to stratify the
        // execution by time:
        val (clockFacts, nonClockFacts) = program.facts.partition(_.tableName == "clock")
        val rulesPlusNonClockFacts = C4CodeGenerator.generate(program.copy(facts=nonClockFacts))
        logger.debug("C4 input minus clock facts is:\n" + rulesPlusNonClockFacts)
        println("C4 input minus clock facts is:\n" + rulesPlusNonClockFacts) //KD
        assert(C4Wrapper.libC4.c4_install_str(c4, rulesPlusNonClockFacts) == 0)
        val clockFactsByTime = clockFacts.groupBy(_.cols(2).asInstanceOf[IntLiteral].int)
        for ((time, facts) <- clockFactsByTime.toSeq.sortBy(_._1)) {
          val clockFactsProgram = C4CodeGenerator.generate(new Program(Nil, facts, Nil))
          logger.debug(s"Installing clock facts for time $time:\n$clockFactsProgram")
          assert(C4Wrapper.libC4.c4_install_str(c4, clockFactsProgram) == 0)
        }
        val tables = program.tables.map {
          t => (t.name, parseTableDump(C4Wrapper.libC4.c4_dump_table(c4, t.name)))
        }.toMap
        new UltimateModel(tables)
      } finally {
        C4Wrapper.libC4.c4_destroy(c4)
        C4Wrapper.libC4.c4_terminate()
      }

    }
  }

  def parseTableDump(string: String): List[List[String]] = {
    string.lines.map(_.split(",").toList).toList
  }
}

object C4Wrapper {
  val libC4: C4 = LibraryLoader.create(classOf[C4]).load("c4")
}
